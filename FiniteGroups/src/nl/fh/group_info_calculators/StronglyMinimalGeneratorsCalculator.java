/*
 * Copyright (C) 2020 Frank Hoogeveen
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package nl.fh.group_info_calculators;

import java.util.ArrayList;
import java.util.List;
import nl.fh.info_table.Calculator;
import nl.fh.info_table.InfoTable;
import nl.fh.info_table.InfoTableException;
import nl.fh.info_table.Property;
import nl.fh.info_table.Value;
import nl.fh.info_table_values.FamilyValue;
import nl.fh.info_table_values.IntArray2dValue;
import nl.fh.info_table_values.IntValue;
import nl.fh.info_table_values.SubsetValue;

/**
 * Calculates the  strongly minimal sets of generators. These are the sets that
 * 1) Generate the entire group
 * 2) Do not have a subset the generates the entire group
 * 3) Are not larger than any other set of generators of the group
 * 
 * Note that minimal sets of generators that comply with 1,2 but not 3 may have 
 * different size, E.g. for C6, <1>, <5>,<2,3> and <3,4> are all minimal generating
 * sets, but only <1> and <5> are strongly minimal.
 * 
 * The current implementation is not the most efficient, but gives 
 * readable code. 
 * 
 * @author frank
 */
public class StronglyMinimalGeneratorsCalculator implements Calculator {

    public StronglyMinimalGeneratorsCalculator() {
    }

    @Override
    public Property getProperty() {
        return GroupProperty.StronglyMinimalGeneratingSets;
    }

    @Override
    public Value evaluate(InfoTable info) throws InfoTableException {

        int[][] table = ((IntArray2dValue)info.getValue(GroupProperty.MultiplicationTable)).content();
        int order = table.length;
        int unit = ((IntValue)info.getValue(GroupProperty.UnitElement)).content();
        
        // create a list which contains an empty subset
        boolean[] empty = new boolean[order];
        for(int i = 0; i < order; i++){
            empty[i] = false;
        }
        List<SubsetValue> currentSets = new ArrayList<SubsetValue>();
        currentSets.add(new SubsetValue(empty));

        //set up the structure that will contain the results
        List<SubsetValue> result = new ArrayList<SubsetValue>();
        
        // iteratively look for the minimal size
        while(result.isEmpty()){
            
            for(SubsetValue set : currentSets){
                SubsetValue generated = generatedFrom(set, table, unit);
                if(generated.isAll()){
                    result.add(set);
                }
            }
            
            // find one-larger subsets
            currentSets = nextLevel(currentSets);
        }
        
        //wrap the result and return
        boolean[][] matrix = new boolean[result.size()][order];
        for(int i = 0; i < result.size(); i++){
            matrix[i] = result.get(i).content();
        }
        
        return new FamilyValue(matrix);
    }

    /**
     * 
     * @param currentSets a list that contain all k-element subsets
     * 
     * @return a list that contains all (k+1) element subsets 
     */
    private List<SubsetValue> nextLevel(List<SubsetValue> currentSets) {
        List<SubsetValue> result  = new ArrayList<SubsetValue>();
        
        for(SubsetValue set : currentSets){
            boolean[] s = set.content();
            int index = 0;
            while(index<s.length && !s[index]){
                boolean[] r = s.clone();
                r[index] = true;
                result.add(new SubsetValue(r));
                index++;
            }
        }
        
        return result;
    }

    /**
     * 
     * @param set a set of generators
     * @param table the multiplication table
     * @return the set that is generated by <set>, using the multiplication table 
     */
    private SubsetValue generatedFrom(SubsetValue set, int[][] table, int unit) {
        
        boolean[] current = set.content().clone();
        current[unit] = true;   // the empty product is equal to the unit element
        int startSize;
        
        do{
            startSize = count(current);
            boolean[] next = current.clone();
            for(int i = 0; i < table.length; i++){
                for(int j = 0; j < table.length; j++){
                    if(current[i] && current[j]){
                        next[table[i][j]] = true;
                    }
                }
            }
            current = next;
        } while(count(current) > startSize);
        
        return new SubsetValue(current);
        
    }

    /**
     * 
     * @param current
     * @return  the number of bits set to true
     */
    private int count(boolean[] current) {
        int result = 0;
        for(boolean b : current){
            if(b){
                result++;
            }
        }
        return result;
    }

}
