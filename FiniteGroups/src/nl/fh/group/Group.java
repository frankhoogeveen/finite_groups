/*
 * Copyright (C) 2020 Frank Hoogeveen
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package nl.fh.group;

import nl.fh.calculator.PropertyCache;
import nl.fh.group_calculators.GroupProperty;
import nl.fh.group_calculators.GroupTable;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import nl.fh.calculator.EvaluationException;
import nl.fh.homomorphism.GroupHomomorphism;
import nl.fh.homomorphism.HomomorphismException;

/**
 *
 * @author frank
 */
public class Group extends PropertyCache<GroupProperty> 
          implements Iterable<Element>{

    /**
     * 
     * @param name
     * @param generators
     * @param multiplication
     * @throws nl.fh.group.GroupException
     * 
     * The constructor calculates and stores the multiplication table and the set of elements (and the name). All other
     * properties are calculated on-demand.
     */
    public Group(String name, Collection<Element> generators, Multiplicator multiplication) throws GroupException {
       
        super();
        
        try{
            Set<Element> toBeAdded = new HashSet(generators);
            Set<Element> elements = findGeneratedSet(toBeAdded, multiplication);
            Multiplicator table = createMultiplicationTable(elements, multiplication);
            
            this.cache.put(GroupProperty.Name, name);
            this.cache.put(GroupProperty.Elements, elements);
            this.cache.put(GroupProperty.MultiplicationTable, table);

        } catch(EvaluationException e){
            throw new GroupException("could not construct group " + name);
        }
    }

    /**
     * 
     * @param subgroup
     * @return a group homomorphism that embeds the subgroup in this group
     * @throws HomomorphismException
     * @throws EvaluationException 
     */
    public GroupHomomorphism embed(Group subgroup) throws HomomorphismException, EvaluationException {
        Set<Element> elementsSubgroup = (Set<Element>) subgroup.getProperty(GroupProperty.Elements);
        Set<Element> elementsGroup = (Set<Element>) this.getProperty(GroupProperty.Elements); 
        
        if(!elementsGroup.containsAll(elementsSubgroup)){
            throw new HomomorphismException("cannot embed something that is not a subset");
        }
        
        Map<Element, Element> identityMap = new HashMap<Element, Element>();
        for(Element g : elementsSubgroup){
            identityMap.put(g,g);
        }
        
        return new GroupHomomorphism(subgroup, this, identityMap);
    }
    
    /**
     * 
     * @param set
     * @return the homomorphism representing the embedding of the subgroup generated by set into this group
     * @throws EvaluationException
     * @throws GroupException
     * @throws HomomorphismException 
     */
    public GroupHomomorphism embed(Set<Element> set) throws EvaluationException, GroupException, HomomorphismException{
        return this.embed(generateSubgroup(set));
    }
    
    /**
     * 
     * @param set
     * @return the group generated by set, i.e. <set>
     * @throws EvaluationException
     * @throws GroupException 
     */
    public Group generateSubgroup(Set<Element> set) throws EvaluationException, GroupException{
        String name = "Subset";
        Set<Element> generatedSet = generateSubset(set);
        Multiplicator table = (Multiplicator) this.getProperty(GroupProperty.MultiplicationTable);
        
        return new Group(name, generatedSet, table);
    }
    
    /**
     * 
     * @param set of elements
     * @return the smallest set that contains set and is closed under 
     * the group operation
     */
    public Set<Element> generateSubset(Set<Element> set) throws EvaluationException{
        Multiplicator mult = (Multiplicator)this.getProperty(GroupProperty.MultiplicationTable);
        
        try {
            return findGeneratedSet(set, mult);
        } catch (EvaluationException ex) {
            String mess = "generatedFrom failed";
            Logger.getLogger(Group.class.getName()).log(Level.SEVERE, mess, ex);
            throw new EvaluationException(mess);
        }
    }    
    
    /**
     * 
     * @param set
     * @param multiplication
     * @return the smallest set that contains "set" and is closed under 
     * the group operation "multiplication"
     * @throws GroupException 
     */
    private Set<Element> findGeneratedSet(Set<Element> set,  Multiplicator multiplication) throws EvaluationException  {
        Set<Element> toBeAdded = new HashSet(set);
        Set<Element> currentTotal = new HashSet();
        
        while(!toBeAdded.isEmpty()){
        Set<Element> nextToBeAdded = new HashSet<Element>();

            for(Element g : toBeAdded){
                for(Element h : currentTotal){
                    Element gh = multiplication.getProduct(g, h);
                    nextToBeAdded.add(gh);

                    Element hg = multiplication.getProduct(h, g);
                    nextToBeAdded.add(hg);
                }

                for(Element g2 : toBeAdded){
                    Element g12 = multiplication.getProduct(g, g2);
                    nextToBeAdded.add(g12);
                }
            }
            
            currentTotal.addAll(toBeAdded);
            toBeAdded = nextToBeAdded;
            toBeAdded.removeAll(currentTotal);
        }
        
        return currentTotal;
    }
    

    /**
     * 
     * @param elements
     * @param multiplication
     * @return a multiplicator with all the products pre-calculated and stored in a table 
     */
    private Multiplicator createMultiplicationTable(Set<Element> elements, Multiplicator multiplication) throws EvaluationException {
        GroupTable table = new GroupTable();
        for(Element g : elements){
            table.put(g, new HashMap<Element, Element>());
            for(Element h : elements){
                table.get(g).put(h, multiplication.getProduct(g, h));
            }
        }
        
        return table;
    }
    
    @Override
    public Iterator<Element> iterator() {
        try {
            return ((Set<Element>)this.getProperty(GroupProperty.Elements)).iterator();
        } catch (EvaluationException ex) {
            String mess = "iterator cannot be defined";
            Logger.getLogger(Group.class.getName()).log(Level.SEVERE, mess, ex);
            throw new IllegalStateException(mess);
        }
    }    
    
    @Override
    public String toString(){
        try {
            return (String) this.getProperty(GroupProperty.Name);
        } catch (EvaluationException ex) {
            String mess = "could not find group name";
            Logger.getLogger(Group.class.getName()).log(Level.SEVERE, mess, ex);
            return mess;
        }
   }
}
